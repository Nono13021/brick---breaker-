<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,user-scalable=no">
<title>Casse-Briques Mobile</title>

<style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body,html {
        display:flex;
        justify-content:center;
        align-items:center;
        height:100vh;
        background:linear-gradient(135deg,#667eea,#764ba2);
        font-family:Arial, sans-serif;
        overflow:hidden;
        touch-action:none;
    }
    #score {
        position:absolute;
        top:10px;
        color:white;
        font-size:28px;
        font-weight:bold;
    }
    canvas {
        border:4px solid white;
        border-radius:14px;
        background:#1a1a2e;
        touch-action:none;
    }
    #gameOver {
        position:absolute;
        top:50%;
        left:50%;
        transform:translate(-50%,-50%);
        background:rgba(0,0,0,0.9);
        color:white;
        padding:20px 40px;
        border-radius:12px;
        display:none;
        text-align:center;
    }
    #gameOver h2 {
        font-size:40px;
    }
    button {
        margin-top:15px;
        padding:12px 35px;
        font-size:20px;
        background:#667eea;
        border:none;
        border-radius:10px;
        color:white;
        cursor:pointer;
    }
</style>
</head>

<body>
<div id="score">Score: 0</div>
<canvas id="gameCanvas"></canvas>

<div id="gameOver">
    <h2>Game Over !</h2>
    <p id="finalScore"></p>
    <button onclick="restartGame()">Rejouer</button>
</div>

<script>

const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d");

let score = 0;
let gameRunning = true;
let particles = [];

// ✅ Responsive canvas
function resizeGame() {
    const baseWidth = 800;
    const baseHeight = 600;
    const scale = Math.min(window.innerWidth / baseWidth, window.innerHeight / baseHeight);

    canvas.width = baseWidth * scale;
    canvas.height = baseHeight * scale;
}
resizeGame();
window.addEventListener("resize", resizeGame);


const isMobile = window.innerWidth < 900;

// ✅ Raquette
const paddle = {
    width: 120,
    height: 15,
    x: canvas.width/2 - 60,
    y: canvas.height - 40,
    speed: isMobile ? 14 : 9,
    dx: 0
};

// ✅ Balle
function randomBallDirection() {
    const ang = (Math.random() * 60 + 60) * Math.PI / 180;
    const d = Math.random() < 0.5 ? 1 : -1;
    return {
        dx: Math.cos(ang) * (isMobile ? 8 : 5) * d,
        dy: -Math.abs(Math.sin(ang) * (isMobile ? 8 : 5))
    };
}

const ball = {
    x: canvas.width/2,
    y: canvas.height/2,
    radius: 8,
    dx: randomBallDirection().dx,
    dy: randomBallDirection().dy
};

// ✅ Briques
const brickConfig = {
    rows: 6,
    cols: 10,
    width: 70,
    height: 25,
    padding: 10,
    offsetX: 35,
    offsetY: 60
};

let bricks = [];
const colors = ['#FF6B6B','#4ECDC4','#45B7D1','#FFA07A','#98D8C8','#F7DC6F'];

function createBricks() {
    bricks = [];
    for (let r=0; r<brickConfig.rows; r++) {
        bricks[r] = [];
        for (let c=0; c<brickConfig.cols; c++) {
            bricks[r][c] = {
                x: c*(brickConfig.width+brickConfig.padding)+brickConfig.offsetX,
                y: r*(brickConfig.height+brickConfig.padding)+brickConfig.offsetY,
                visible:true,
                color:colors[r%colors.length]
            }
        }
    }
}

// ✅ Déplacement balle
function moveBall() {
    ball.x += ball.dx;
    ball.y += ball.dy;

    if (ball.x-ball.radius < 0 || ball.x+ball.radius > canvas.width)
        ball.dx *= -1;

    if (ball.y-ball.radius < 0)
        ball.dy *= -1;

    if (ball.y+ball.radius > canvas.height) {
        gameRunning=false;
        document.getElementById("gameOver").style.display="block";
        document.getElementById("finalScore").textContent=`Score Final : ${score}`;
    }

    // ✅ Collision raquette
    if (ball.y+ball.radius > paddle.y &&
        ball.x > paddle.x && ball.x < paddle.x+paddle.width) {

        ball.dy = -Math.abs(ball.dy);
        let hitPos = (ball.x-paddle.x)/paddle.width;
        ball.dx = (hitPos-0.5)* (isMobile ? 18 : 14);
    }

    // ✅ Collision briques
    bricks.forEach(row=>{
        row.forEach(b=>{
            if(b.visible && ball.x+ball.radius>b.x && ball.x-ball.radius<b.x+brickConfig.width &&
               ball.y+ball.radius>b.y && ball.y-ball.radius<b.y+brickConfig.height) {
                    b.visible=false;
                    score+=10;
                    document.getElementById("score").textContent=`Score: ${score}`;
                    ball.dy *= -1;
            }
        });
    });
}

// ✅ Déplacement raquette
function movePaddle() {
    paddle.x += paddle.dx;
    if(paddle.x<0) paddle.x=0;
    if(paddle.x+paddle.width>canvas.width) paddle.x=canvas.width-paddle.width;
}

// ✅ Affichage
function draw() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // bricks
    bricks.forEach(row=>{
        row.forEach(b=>{
            if(b.visible){
                ctx.fillStyle=b.color;
                ctx.fillRect(b.x,b.y,brickConfig.width,brickConfig.height);
            }
        });
    });

    // paddle
    ctx.fillStyle="#00ff88";
    ctx.fillRect(paddle.x,paddle.y,paddle.width,paddle.height);

    // ball
    ctx.beginPath();
    ctx.fillStyle="#fff";
    ctx.arc(ball.x,ball.y,ball.radius,0,Math.PI*2);
    ctx.fill();
}

function update() {
    if(!gameRunning) return;
    movePaddle();
    moveBall();
    draw();
    requestAnimationFrame(update);
}

// ✅ Clavier pour PC
document.addEventListener("keydown", e=>{
    if(e.key==="ArrowRight"||e.key==="d") paddle.dx = paddle.speed;
    if(e.key==="ArrowLeft"||e.key==="q") paddle.dx = -paddle.speed;
});
document.addEventListener("keyup", ()=> paddle.dx = 0);

// ✅ Touch Mobile
function handleTouch(e){
    e.preventDefault();
    const rect=canvas.getBoundingClientRect();
    const touch=e.touches[0]||e.changedTouches[0];
    const x=(touch.clientX-rect.left)*(canvas.width/rect.width);
    paddle.x=x-paddle.width/2;
}
document.addEventListener("touchstart",handleTouch,{passive:false});
document.addEventListener("touchmove",handleTouch,{passive:false});

// ✅ Restart
function restartGame(){
    score=0;
    gameRunning=true;
    document.getElementById("score").textContent="Score: 0";
    document.getElementById("gameOver").style.display="none";
    paddle.x=canvas.width/2-60;
    ball.x=canvas.width/2;
    ball.y=canvas.height/2;
    const d=randomBallDirection();
    ball.dx=d.dx;
    ball.dy=d.dy;
    createBricks();
    update();
}

createBricks();
update();

</script>
</body>
</html>
